import{L as X,F as Q,C as T,S as Z,G as $,B as E,a as L,b as A,M as D,P,c as k,d as B,e as O,f as G,V as _,g as ee,h as te,W as se,A as ne,D as ie,T as oe,i as re}from"./vendor-CISswKMV.js";(function(){const s=document.createElement("link").relList;if(s&&s.supports&&s.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))i(e);new MutationObserver(e=>{for(const n of e)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function t(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?n.credentials="include":e.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(e){if(e.ep)return;e.ep=!0;const n=t(e);fetch(e.href,n)}})();const ae=/^[og]\s*(.+)?/,le=/^mtllib /,ce=/^usemtl /,he=/^usemap /,N=/\s+/,H=new _,U=new _,R=new _,W=new _,y=new _,C=new T;function de(){const v={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=t!==!1;return}const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,n){const r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);const f={index:this.materials.length,name:e||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:r!==void 0?r.smooth:this.smooth,groupStart:r!==void 0?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(g){const a={index:typeof g=="number"?g:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(f),f},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),e&&this.materials.length>1)for(let r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},i&&i.name&&typeof i.clone=="function"){const e=i.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/3)*3},parseNormalIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/3)*3},parseUVIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/2)*2},addVertex:function(s,t,i){const e=this.vertices,n=this.object.geometry.vertices;n.push(e[s+0],e[s+1],e[s+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[i+0],e[i+1],e[i+2])},addVertexPoint:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addVertexLine:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addNormal:function(s,t,i){const e=this.normals,n=this.object.geometry.normals;n.push(e[s+0],e[s+1],e[s+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[i+0],e[i+1],e[i+2])},addFaceNormal:function(s,t,i){const e=this.vertices,n=this.object.geometry.normals;H.fromArray(e,s),U.fromArray(e,t),R.fromArray(e,i),y.subVectors(R,U),W.subVectors(H,U),y.cross(W),y.normalize(),n.push(y.x,y.y,y.z),n.push(y.x,y.y,y.z),n.push(y.x,y.y,y.z)},addColor:function(s,t,i){const e=this.colors,n=this.object.geometry.colors;e[s]!==void 0&&n.push(e[s+0],e[s+1],e[s+2]),e[t]!==void 0&&n.push(e[t+0],e[t+1],e[t+2]),e[i]!==void 0&&n.push(e[i+0],e[i+1],e[i+2])},addUV:function(s,t,i){const e=this.uvs,n=this.object.geometry.uvs;n.push(e[s+0],e[s+1]),n.push(e[t+0],e[t+1]),n.push(e[i+0],e[i+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const t=this.uvs;this.object.geometry.uvs.push(t[s+0],t[s+1])},addFace:function(s,t,i,e,n,r,f,g,a){const h=this.vertices.length;let o=this.parseVertexIndex(s,h),l=this.parseVertexIndex(t,h),d=this.parseVertexIndex(i,h);if(this.addVertex(o,l,d),this.addColor(o,l,d),f!==void 0&&f!==""){const m=this.normals.length;o=this.parseNormalIndex(f,m),l=this.parseNormalIndex(g,m),d=this.parseNormalIndex(a,m),this.addNormal(o,l,d)}else this.addFaceNormal(o,l,d);if(e!==void 0&&e!==""){const m=this.uvs.length;o=this.parseUVIndex(e,m),l=this.parseUVIndex(n,m),d=this.parseUVIndex(r,m),this.addUV(o,l,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const t=this.vertices.length;for(let i=0,e=s.length;i<e;i++){const n=this.parseVertexIndex(s[i],t);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(s,t){this.object.geometry.type="Line";const i=this.vertices.length,e=this.uvs.length;for(let n=0,r=s.length;n<r;n++)this.addVertexLine(this.parseVertexIndex(s[n],i));for(let n=0,r=t.length;n<r;n++)this.addUVLine(this.parseUVIndex(t[n],e))}};return v.startObject("",!1),v}class ue extends X{constructor(s){super(s),this.materials=null}load(s,t,i,e){const n=this,r=new Q(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(s,function(f){try{t(n.parse(f))}catch(g){e?e(g):console.error(g),n.manager.itemError(s)}},i,e)}setMaterials(s){return this.materials=s,this}parse(s){const t=new de;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const i=s.split(`
`);let e=[];for(let f=0,g=i.length;f<g;f++){const a=i[f].trimStart();if(a.length===0)continue;const h=a.charAt(0);if(h!=="#")if(h==="v"){const o=a.split(N);switch(o[0]){case"v":t.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),o.length>=7?(C.setRGB(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6]),Z),t.colors.push(C.r,C.g,C.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":t.uvs.push(parseFloat(o[1]),parseFloat(o[2]));break}}else if(h==="f"){const l=a.slice(1).trim().split(N),d=[];for(let c=0,p=l.length;c<p;c++){const b=l[c];if(b.length>0){const w=b.split("/");d.push(w)}}const m=d[0];for(let c=1,p=d.length-1;c<p;c++){const b=d[c],w=d[c+1];t.addFace(m[0],b[0],w[0],m[1],b[1],w[1],m[2],b[2],w[2])}}else if(h==="l"){const o=a.substring(1).trim().split(" ");let l=[];const d=[];if(a.indexOf("/")===-1)l=o;else for(let m=0,c=o.length;m<c;m++){const p=o[m].split("/");p[0]!==""&&l.push(p[0]),p[1]!==""&&d.push(p[1])}t.addLineGeometry(l,d)}else if(h==="p"){const l=a.slice(1).trim().split(" ");t.addPointGeometry(l)}else if((e=ae.exec(a))!==null){const o=(" "+e[0].slice(1).trim()).slice(1);t.startObject(o)}else if(ce.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(le.test(a))t.materialLibraries.push(a.substring(7).trim());else if(he.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(e=a.split(" "),e.length>1){const l=e[1].trim().toLowerCase();t.object.smooth=l!=="0"&&l!=="off"}else t.object.smooth=!0;const o=t.object.currentMaterial();o&&(o.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const n=new $;if(n.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let f=0,g=t.objects.length;f<g;f++){const a=t.objects[f],h=a.geometry,o=a.materials,l=h.type==="Line",d=h.type==="Points";let m=!1;if(h.vertices.length===0)continue;const c=new E;c.setAttribute("position",new L(h.vertices,3)),h.normals.length>0&&c.setAttribute("normal",new L(h.normals,3)),h.colors.length>0&&(m=!0,c.setAttribute("color",new L(h.colors,3))),h.hasUVIndices===!0&&c.setAttribute("uv",new L(h.uvs,2));const p=[];for(let w=0,I=o.length;w<I;w++){const x=o[w],S=x.name+"_"+x.smooth+"_"+m;let u=t.materials[S];if(this.materials!==null){if(u=this.materials.create(x.name),l&&u&&!(u instanceof A)){const j=new A;D.prototype.copy.call(j,u),j.color.copy(u.color),u=j}else if(d&&u&&!(u instanceof P)){const j=new P({size:10,sizeAttenuation:!1});D.prototype.copy.call(j,u),j.color.copy(u.color),j.map=u.map,u=j}}u===void 0&&(l?u=new A:d?u=new P({size:1,sizeAttenuation:!1}):u=new k,u.name=x.name,u.flatShading=!x.smooth,u.vertexColors=m,t.materials[S]=u),p.push(u)}let b;if(p.length>1){for(let w=0,I=o.length;w<I;w++){const x=o[w];c.addGroup(x.groupStart,x.groupCount,w)}l?b=new B(c,p):d?b=new O(c,p):b=new G(c,p)}else l?b=new B(c,p[0]):d?b=new O(c,p[0]):b=new G(c,p[0]);b.name=a.name,n.add(b)}else if(t.vertices.length>0){const f=new P({size:1,sizeAttenuation:!1}),g=new E;g.setAttribute("position",new L(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(g.setAttribute("color",new L(t.colors,3)),f.vertexColors=!0);const a=new O(g,f);n.add(a)}return n}}const M=new ee;M.background=new T(16765884);const F=new te(75,window.innerWidth/window.innerHeight,.1,1e3);F.position.z=5;const z=new se({antialias:!0});z.setSize(window.innerWidth,window.innerHeight);document.body.appendChild(z.domElement);M.add(new ne(16777215,.6));const q=new ie(16777215,.8);q.position.set(5,5,5);M.add(q);const fe=new oe;fe.load("./Fosfo.jpeg");let V;const me=new ue;me.load("./cerillo.obj",v=>{const t=new re().setFromObject(v).getCenter(new _);v.position.sub(t),v.scale.set(2,2,2),V=v,M.add(v)});let J=0,Y=0;window.addEventListener("scroll",()=>{const v=window.scrollY;J=v*.002,Y=v*.002});function K(){requestAnimationFrame(K),V&&(V.rotation.x+=(J-V.rotation.x)*.1,V.rotation.y+=(Y-V.rotation.y)*.1),z.render(M,F)}K();window.addEventListener("resize",()=>{F.aspect=window.innerWidth/window.innerHeight,F.updateProjectionMatrix(),z.setSize(window.innerWidth,window.innerHeight)});
